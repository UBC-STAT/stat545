---
title: "Lecture 8b: Advanced Functions"
subtitle: "October 23, 2025"
date-modified: last-modified
---

We will learn about a couple of advanced topics:

-   Data-masking and the curly-curly `{{}}`

-   Default values

-   Ellipses `...`

-   Handling `NA`'s

These topics are covered in the [R4DS Functions](https://r4ds.hadley.nz/functions) book chapter as well. So if you miss this class, then the R4DS Functions reading is a good alternative.

We will be using the following packages throughout this lecture:

```{r, warning = F, message = F}
library(palmerpenguins)
library(tidyverse)
library(gapminder)
```

## Video Lecture

{{< video https://www.youtube.com/watch?v=Xu6QR-ptogQ >}}

## Lecture Slides

-   [Lecture 8B - Advanced Functions](../slides/slidefiles/lec8b_advfunctions_slides.qmd)

## Data-masking and the Curly-Curly `{{}}`

Sometimes your function needs to take in variable names without quotation marks and work with them that way.

For example, `select(penguins, species)` does not put quotation marks around `species` (the reasoning being that `lifeExp` is like a variable in our workspace, if we were to include column names in our R Environment) and `select("penguins", "species")` does not work.

We often need to create functions that reference column names without it being a string. If your function needs to do this, then you need to work with the arguments with extra care inside the function definition. Whenever we use those arguments, we need to embrace them within two curly brackets -- an operator called "curly curly".

Take this function that produces a quick scatterplot between two columns in a dataset as an example.

``` r
quick_scatter <- function(data, x, y) {
  ggplot(data, aes(x, y)) + #note curly brackets here!
     geom_point()
}

quick_scatter(penguins, bill_length_mm, body_mass_g)
```

```         
Error in `geom_point()`:
! Problem while computing aesthetics.
ℹ Error occurred in the 1st layer.
Caused by error:
! object 'bill_length_mm' not found
```

Why doesn't this work? The reason is that R is looking for variables named `bill_len` and `body_mass` in the workspace, and cannot find them. To fix the problem, we can change the function definition so that \`x\` and \`y\` are embraced within two curly brackets `{{}}` ("curly curly"):

```{r, warning = F}
quick_scatter <- function(data, x, y) {
  ggplot(data, aes({{ x }}, {{ y }})) + #note curly brackets here!
     geom_point()
}

quick_scatter(penguins, bill_length_mm, body_mass_g)

```

But, you can only use curly-curly when passing your function's argument to another function that's anticipating a variable name without quotation marks.

::: callout-tip
In the \`dplyr\` documentation, if you spy the words "data masking" or "tidy selection", then you will need to curly-curly your arguments when using those functions within your custom function.
:::

::: {.callout-warning appearance="minimal" icon="false"}
### Exercise: Curly Curly

Here’s some code that:

-   groups `penguins` by species, then summarizes the number of missing values in each variable.

-   groups `gapminder` by continent, then summarizes the number of missing values in each variable.

```{r}
penguins %>% 
  group_by(species) %>% 
  summarize(across(everything(), ~ sum(is.na(.x))))
```

```{r}
gapminder %>% 
  group_by(continent) %>% 
  summarize(across(everything(), ~ sum(is.na(.x))))
```

These steps to summarize the data are quite similar! Instead of coding each step multiple times, let's turn it into a function. By yourself or with a partner, write a function that could be used to group by a column name and summarize the number of NAs in a data set. Remember: we need to use the `{{}}` when referring to column names.
:::

::: {.callout-warning collapse="true" icon="false"}
## Click to reveal the solution!

```{r}
summarizeby_fun <- function(data, groups){
  data %>%
    group_by({{groups}}) %>%
    summarize(across(everything(), ~ sum(is.na(.x))))
}

summarizeby_fun(penguins, species)
summarizeby_fun(gapminder, continent)

```
:::

## Default Parameters

Recall the dice-rolling example from the previous lecture. Sometimes you want to use a function frequently without re-writing the same parameters over and over again. Let's make a more flexible function that allows us to **change the number of faces on the dice being rolled**.

```{r}
#' @details
#' Simulates rolling `num_dice` number of dice with `n_sides` sides and outputs the sum. Note: no seed is used so the function will return a dice combination each time it is run
#'
#' @param num_dice integer representing number of dice to be rolled
#' @param n_sides integer representing the number of sides of each dice
#' @return the sum of the dice rolled
  
roll_dice <- function(n_sides, num_dice) { 
  
    # throw an error if num_dice (the input) is not an integer
  
    if(num_dice %% 1 != 0){ #if num_dice mod 1 is NOT 0
      stop("num_dice must be an integer") #throw this error message and stop the function
    }
  
    #if the num_dice is an integer, continue with the function:
    sum(sample(1:n_sides, num_dice, replace=TRUE)) #sample two numbers from one to n_sides with replacement, return sum
}
```

Notice now that in this function, there are two parameters (the new one is `n_sides`). We now sample from `1:nsides` (instead of `1:10)` to make the function more flexible. I also renamed the function to `roll_dice` as we are not necessarily rolling 10 sided dice.

So to roll two 10-sided dice, I can call:

```{r}
roll_dice(n_sides = 10, num_dice = 2)
```

Now, perhaps I often want to roll ten-sided dice. To avoid having to type `n_sides = 10`, I can simply make the default number of sides to 10!

```{r}
#' @details
#' Simulates rolling `num_dice` number of dice with `n_sides` sides and outputs the sum. Note: no seed is used so the function will return a dice combination each time it is run
#'
#' @param num_dice integer representing number of dice to be rolled
#' @param n_sides integer representing the number of sides of each dice. Default is 10.
#' @return the sum of the dice rolled
  
roll_dice <- function(n_sides = 10, num_dice) { #NEW: n_sides default is 10
  
    # throw an error if num_dice (the input) is not an integer
  
    if(num_dice %% 1 != 0){ #if num_dice mod 1 is NOT 0
      stop("num_dice must be an integer") #throw this error message and stop the function
    }
  
    #if the num_dice is an integer, continue with the function:
    sum(sample(1:n_sides, num_dice, replace=TRUE)) #sample two numbers from one to n_sides with replacement, return sum
}
```

We have set `n_sides = 10` as the default. This means the function will assume we have a 10 sided dice unless otherwise specified. Let's roll 3 dice using 10 sided dice (the default):

```{r}
roll_dice(num_dice = 3)
```

I didn't need to include `n_sides = 10` in my function call! But I can if I want to change it to a number other than 10. Let's roll 3 standard 6-sided dice

```{r}
roll_dice(n_sides = 6, num_dice = 3)
```

::: {.callout-warning appearance="minimal" icon="false"}
## Exercise: Default Values

Make a new argument for the `summarizeby_fun()` we made previously called `columns` that allows you to input a vector containing which columns you wish to look at missing values for (these can be written as strings). Set the default to `everything()`.
:::

::: {.callout-warning collapse="true" icon="false"}
## Click to reveal the solution!

```{r}
summarizeby_fun <- function(data, groups, columns = everything()){
  data %>%
    group_by({{groups}}) %>%
    summarize(across(columns, ~ sum(is.na(.x))))
}

summarizeby_fun(penguins, species)
summarizeby_fun(penguins, species, c("bill_length_mm", "sex"))

```
:::

## **Ellipses (`...`**)

The ellipses allow a function to accept a variable number of additional unnamed arguments beyond what is explicitly written in the function. Many built-in functions have `...` listed (check out `c()`!)

Let's modify our function to allow grouping by any number of variables.

```{r}
summarizeby_fun <- function(data, ..., columns = everything()){
  data %>%
    group_by(...) %>%
    summarize(across(columns, ~ sum(is.na(.x))))
}

summarizeby_fun(penguins, species)
summarizeby_fun(penguins, species, island)

```

Now our function is very flexible! And as a bonus, we didn't need to use the `{{}}`.

## Handling `NA`s

Missing data is essentially inevitable. Few studies are able to collect 100% of the data they intend to.

Missing data can *heavily* complicate analyses and even lead to biased results when not handled properly. Missing data is a big research area in statistics! But for this class, we are going to focus on dealing with missing data using a simple example.

Let's look at the flipper length of penguins in the `penguins` data set and count how many missing values there are using the `is.na()` function in R. `is.na(flipper_len)` will return a vector full of `TRUE` or `FALSE` values indicating whether or not the observation was missing. As `TRUE` is coded as a 1 and `FALSE` as a 0, we can sum over these to count how many missing values there are.

```{r}
flipper_len <- penguins$flipper_length_mm #save this data as its own vector
sum(is.na(flipper_len)) # count how many NAs there are in the flipper data
```

We see we have two missing values. Let's see if we can summarize the quantiles of the lengths:

``` r
quantile(flipper_len)
```

```         
Error in quantile.default(flipper_length) :
missing values and NaN's not allowed if 'na.rm' is FALSE
```

We see here that missing values are not allowed unless we specify `na.rm = TRUE`. When `na.rm = TRUE`, we remove missing values from the data and then calculate the quantiles. This is also referred to as a *complete case analysis.*

```{r}
quantile(flipper_len, na.rm = TRUE)
```

Now suppose we wanted to make our own function that utilized the `quantile()` built-in function:

```{r}
#' @details
#' calculates the range of data by finding the 100th and 0th quantile and finding their difference
#'
#' @param vec a vector that we want to find the range of
#' @return the difference in the maximum and minimum
  
get_range <- function(vec){
  quantiles <- quantile(vec, na.rm = TRUE) #calc quantiles, remove NA's
  return(max(quantiles) - min(quantiles)) #calculate and return the range
}

get_range(flipper_len)
```

We could also include `na.rm` in our function parameters to allow the user to specify whether or not it should be set to `TRUE` or `FALSE`. We can use a default, as well.

```{r}
#' @details
#' calculates the range of data by finding the 100th and 0th quantile and finding their difference
#'
#' @param vec a vector that we want to find the range of
#' @param na.rm logical, whether or not to remove NAs. Default set to TRUE.
#' @return the difference in the maximum and minimum
  
get_range <- function(vec, na.rm = TRUE){
  quantiles <- quantile(vec, na.rm = na.rm) #calc quantiles, remove NA's
  return(max(quantiles) - min(quantiles)) #calculate and return the range
}

get_range(flipper_len) #default to true
```

## Worksheet B1 and Assignment B1

You can now begin working on [Worksheet B1](https://github.com/UBC-STAT/STAT545.github.io/blob/main/content/worksheets_student/worksheet_b01.ipynb) and [Assignment B1 (pdf on Canvas)](https://canvas.ubc.ca/courses/170035/files/42178437).
