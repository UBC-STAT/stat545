---
title: "Lecture 8B: Advanced Functions"
subtitle: "STAT 545 - Fall 2025"
format: 
  live-revealjs:
    scrollable: true
    slide-number: true
    smaller: true
    auto-stretch: false
    menu: 
      side: right
      width: wide
webr:
  packages:
    - tidyverse
    - knitr
    - palmerpenguins
    - gapminder
  persist: true
editor: visual
execute:
  echo: true
  warning: false
engine: webr
---

{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

```{r, include = F}
library(palmerpenguins)
library(tidyverse)
library(gapminder)
```

## We will learn about a couple of advanced topics:

-   Data-masking and the curly-curly `{{}}`

-   Default values

-   Ellipses `...`

-   Handling `NA`'s

[Lecture Notes](https://ubc-stat.github.io/STAT545.github.io/webpages/lectures_ii/lec8b_advfunctions.html)

[YouTube Video](https://www.youtube.com/watch?v=Xu6QR-ptogQ&t=1s)

## Set-up

We will be using the following packages throughout this lecture:

```{webr, warning = F, message = F}
library(palmerpenguins)
library(tidyverse)
library(gapminder)
```

## Data-masking and the Curly-Curly `{{}}`

Sometimes your function needs to take in variable names without quotation marks and work with them that way.

For example,

-   `select(penguins, species)` works

-   `select("penguins", "species")` does not work.

We often need to create functions that reference column names **without** it being a string.

If your function needs to do this, we need to embrace them within two curly brackets -- an operator called "curly curly".

## Data-masking and the Curly-Curly `{{}}`

Take this function that produces a quick scatterplot between two columns in a dataset as an example.

```{webr}
quick_scatter <- function(data, x, y) {
  ggplot(data, aes(x, y)) + #note curly brackets here!
     geom_point()
}

quick_scatter(penguins, bill_length_mm, body_mass_g)
```

Why doesn't this work?

::: {contenteditable="true" style="border: 0.1px solid black; padding: 8px; font-size: 18px;"}
Notes:
:::

## Data-masking and the Curly-Curly `{{}}`

The reason is that R is looking for variables named `bill_len` and `body_mass` in the workspace, and cannot find them. To fix the problem, we can change the function definition so that \`x\` and \`y\` are embraced within two curly brackets `{{}}` ("curly curly"):

```{webr, warning = F}
quick_scatter <- function(data, x, y) {
  ggplot(data, aes({{ x }}, {{ y }})) + #note curly brackets here!
     geom_point()
}

quick_scatter(penguins, bill_length_mm, body_mass_g)

```

But, you can only use curly-curly when passing your function's argument to another function that's anticipating a variable name without quotation marks.

::: {contenteditable="true" style="border: 0.1px solid black; padding: 8px; font-size: 18px;"}
Notes:
:::

## Curly-Curly `{{}}` Exercise

Hereâ€™s some code that:

-   groups `penguins` by species, then summarizes the number of missing values in each variable.

-   groups `gapminder` by continent, then summarizes the number of missing values in each variable.

```{webr}
penguins %>% 
  group_by(species) %>% 
  summarize(across(everything(), ~ sum(is.na(.x))))
```

```{webr}
gapminder %>% 
  group_by(continent) %>% 
  summarize(across(everything(), ~ sum(is.na(.x))))
```

<br>

Write a function that could be used to group by a column name and summarize the number of NAs in a data set. \*Remember: we need to use the `{{}}` when referring to column names\*.

```{webr}

```

## Multiple Arguments

Recall the dice-rolling example from the previous lecture.

Sometimes you want to use a function frequently without re-writing the same parameters over and over again. Let's make a more flexible function that allows us to **change the number of faces on the dice being rolled**.

```{webr}
#' Roll any number of any-sided dice
#' Simulates rolling `num_dice` number of dice with `n_sides` sides and outputs the sum.  
#'
#' @param num_dice integer representing number of dice to be rolled
#' @param n_sides integer representing the number of sides of each dice
#' @return the sum of the dice rolled
  
roll_dice <- function(n_sides, num_dice) { 
  
    # throw an error if num_dice (the input) is not an integer
  
    if(num_dice %% 1 != 0){ #if num_dice mod 1 is NOT 0
      stop("num_dice must be an integer") #throw this error message and stop the function
    }
  
    #if the num_dice is an integer, continue with the function:
    sum(sample(1:n_sides, num_dice, replace=TRUE)) #sample two numbers from one to n_sides with replacement, return sum
}
```

So to roll two 10-sided dice, I can call:

```{webr}
roll_dice(n_sides = 10, num_dice = 2)
```

## Multiple Arguments

NOTE: with multi-argument functions, you can either list the arguments in order that they appear in the function, or be explicit with the parameter names. The following are equivalent:

-   `roll_dice(10, 2)`

-   `roll_dice(n_sides = 10, num_dice = 2)`

-   `roll_dice(num_dice = 2, n_sides = 10)`

## Default Parameters

Now, perhaps I often want to roll ten-sided dice. To avoid having to type `n_sides = 10`, I can simply make the default number of sides to 10!

```{webr}
#' Roll any number of any-sided dice
#' Simulates rolling `num_dice` number of dice with `n_sides` sides and outputs the sum.  
#'
#' @param num_dice integer representing number of dice to be rolled
#' @param n_sides integer representing the number of sides of each dice. ...
#' @return the sum of the dice rolled
  
roll_dice <- function(n_sides, num_dice) { 
  
    # throw an error if num_dice (the input) is not an integer
  
    if(num_dice %% 1 != 0){ #if num_dice mod 1 is NOT 0
      stop("num_dice must be an integer") #throw this error message and stop the function
    }
  
    #return the sum of the die rolls
    sum(sample(1:n_sides, num_dice, replace=TRUE)) 
}
```

## Default Parameters

We have set `n_sides = 10` as the default. This means the function will assume we have a 10 sided dice unless otherwise specified. Let's roll 3 dice using 10 sided dice (the default):

```{webr}
roll_dice(num_dice = 3)
```

<br>

I didn't need to include `n_sides = 10` in my function call! But I can if I want to change it to a number other than 10. Let's roll 3 standard 6-sided dice

```{webr}
roll_dice(...)
```

## Exercise: Default Values

Make a new argument for the `summarizeby_fun()` we made previously called `columns` that allows you to input a vector containing which columns you wish to look at missing values for (these can be written as strings). Set the default to `everything()`.

```{webr}
summarizeby_fun <- function(data, groups, ...){
  data %>%
    group_by({{groups}}) %>%
    summarize(across(..., ~ sum(is.na(.x))))
}

summarizeby_fun(penguins, species)
summarizeby_fun(penguins, species, c("sex", "flipper_length_mm"))

```

## **Ellipses (`...`**)

The ellipses allow a function to accept a variable number of additional unnamed arguments beyond what is explicitly written in the function. Many built-in functions have `...` listed:

```{webr}
?c #function used to make a vector
```

## **Ellipses (`...`**)

Let's modify our function to allow grouping by any number of variables.

```{webr}
summarizeby_fun <- function(data, groups, columns = everything()){
  data %>%
    group_by({{groups}}) %>%
    summarize(across(columns, ~ sum(is.na(.x))))
}

summarizeby_fun(penguins, species)
summarizeby_fun(penguins, species, island)

```

Now our function is very flexible! And as a bonus, we didn't need to use the `{{}}`.

## Handling `NA`s

Missing data is inevitable. Few studies are able to collect 100% of the data they intend to.

Missing data is a big research area in statistics! But for this class, we are going to focus on dealing with missing data using a simple example.

Let's look at the flipper length of penguins in the `penguins` data set and count how many missing values there are using the `is.na()` function in R.

-   `is.na(flipper_len)` will return a vector full of `TRUE` or `FALSE` values indicating whether or not the observation was missing.

-   As `TRUE` is coded as a 1 and `FALSE` as a 0, we can sum over these to count how many missing values there are.

## Handling `NA`s

```{webr}
flipper_len <- penguins$flipper_length_mm #save this data as its own vector
sum(is.na(flipper_len)) # count how many NAs there are in the flipper data
```

We see we have two missing values. Let's see if we can summarize the quantiles of the lengths:

```{webr}
quantile(flipper_len)
```

We see here that missing values are not allowed unless we specify `na.rm = TRUE`. When `na.rm = TRUE`, we remove missing values from the data and then calculate the quantiles. This is also referred to as a *complete case analysis.*

```{webr}
quantile(flipper_len, na.rm = TRUE)
```

## Handling `NA`s

Now suppose we wanted to make our own function that utilized the `quantile()` built-in function:

```{webr}
#' Get Range
#' calculates the range of data by finding the 100th and 0th quantile and finding their difference
#'
#' @param vec a vector that we want to find the range of
#' @return the difference in the maximum and minimum
  
get_range <- function(vec){
  quantiles <- quantile(vec, na.rm = TRUE) #calc quantiles, remove NA's
  return(max(quantiles) - min(quantiles)) #calculate and return the range
}

get_range(flipper_len)
```

## Handling `NA`s

We could also include `na.rm` in our function parameters to allow the user to specify whether or not it should be set to `TRUE` or `FALSE`. We can use a default, as well.

```{webr}
#' Get Range
#' calculates the range of data by finding the 100th and 0th quantile and finding their difference
#'
#' @param vec a vector that we want to find the range of
#' @param removenas
#' @return the difference in the maximum and minimum
  
get_range <- function(vec, .....){
  quantiles <- quantile(vec, .....) #calc quantiles, remove NA's
  return(max(quantiles) - min(quantiles)) #calculate and return the range
}

get_range(flipper_len) #default to true
```

## Worksheet B1

Get some practice with advanced functions on Worksheet B1, or begin on Assignment B1.
